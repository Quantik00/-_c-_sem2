#include <iostream>
#include <thread> // для работы с потоками
#include <vector> // для хранения потоков
#include <mutex>// для синхронизации вывода (безопасный вывод из нескольких потоков)

using namespace std;
mutex cout_mutex; // для синхронизации вывода

void printMessage(int thread_number, int total_threads) {
    lock_guard<mutex> lock(cout_mutex); // защищаем cout: захватываем мьютекс и освобождаем его при выходе из области видимости
    cout << "Thread number: " << thread_number
         << ", Total Threads: " << total_threads
         << ", Message: HelloWorld" << endl;
         << " Вывод не всегда будет идентичен:"<< 
         << " 1) Параллельное выполнение: потоки выполняются одновременно, и порядок их завершения и вывода не определён. Даже при наличии мьютекса порядок его захвата не дано предугадать."<< 
         << " 2) Планировщик потоков: операционная система определяет порядок выполнения потоков, этот выбор может различаться при каждом запуске."<< 
         << " 3) Отсутствие синхронизации порядка запуска: хотя вывод защищён от одновременного доступа, пордок вывода так же не. определён."<< 
}

int main() {
    const int num_threads = 8;
    vector<thread> threads;// вектор для хранения потоков

    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back(printMessage, i, num_threads); // создаем и запускаем поток, передаем ему номер потока и общее количество потоков
    }

    for (auto& t : threads) { // по ссылке, чтобы не копировать, перебираем по вектору потоков
        t.join();// join говорит главному потоку программы: «Подожди, пока поток t полностью завершится».
    }

    return 0;
}
